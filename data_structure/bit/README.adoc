= 位运算
:toc:
:toclevels: 5
:toc-title: 目录
:sectnums:

计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。

== 位操作符
=== & 与运算
& 与运算 两个位都是 1 时，结果才为 1，否则为 0，如
```
1 0 0 1 1
& 1 1 0 0 1
------------------------------
1 0 0 0 1
```

=== | 或运算
两个位都是 0 时，结果才为 0，否则为 1，如
```
1 0 0 1 1
| 1 1 0 0 1
------------------------------
1 1 0 1 1
```

=== ^ 异或运算
两个位相同则为 0，不同则为 1，如
```
1 0 0 1 1
^ 1 1 0 0 1
-----------------------------
0 1 0 1 0
```

=== ~ 取反运算
0 则变为 1，1 则变为 0，如
```
~ 1 0 0 1 1
-----------------------------
0 1 1 0 0
```

=== << 左移运算
```
int a = 8;
a << 3;
移位前：0000 0000 0000 0000 0000 0000 0000 1000
移位后：0000 0000 0000 0000 0000 0000 0100 0000
```

=== >> 右移运算
向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如

```
unsigned int a = 8;
a >> 3;
移位前：0000 0000 0000 0000 0000 0000 0000 1000
移位后：0000 0000 0000 0000 0000 0000 0000 0001
​
int a = -8;
a >> 3;
移位前：1111 1111 1111 1111 1111 1111 1111 1000
移位前：1111 1111 1111 1111 1111 1111 1111 1111

```

== 有符号数和无符号数
=== 有符号数
有符号数的定义是：字节的最高位作为符号位，其余的是数值位。例如一个字节中存储的二进制数为1100 1000，最高位1作为符号位，其余的7为 100 1000 作为数值为。

那么，符号位占据1位，就有0和1这样的两种数值，就有：

- 如果符号位为0，那么字节中存储的数值是正数
- 如果符号位为1，那么字节中存储的数值是负数

对于1100 1000这样的二进制数据，符号位是1，就表示负数。

在有符号数中，表示负数的算法是：

- 把数值位中存储的二进制数据，每个位都取反，就是原来为0的值变为1，原来为1的值变为0；
- 给对取反后的二进制数据加1，得到的数值就得到负数值；

=== 无符号数
无符号数的定义是：没有符号位，所有的位数都是数值位。所以表示的都是正数。

=== 例子
==== 例一
1100 1000这个数值，如果作为有符号数看待，那么符号位是1，数值位是100 1000。所以，符号位是1，所以，这个数据是负数。然后，表示成十进制时，对数值位的操作是：

- 数值位取反，得到011 0111；
- 对取反后的数值 011 0111加1得到011 1000，数值位的值为56；

那么，1100 1000这个二进制数据表示为“有符号数”时，就是-56这个数值。

如果作为无符号数看待，那么，就没有符号位，所有的位数都是数值位，所以11001000都作为数值位，表示的十进制数值是200

==== 例二
例如，0111 0011这个数值，如果当做“有符号数”看待，那么，其符号位是0，所以，表示整数，数值位是115，所以，表示正115这个数值。如果当做无符号数看待，所有位都是数值位，计算得到115这个数值，所以，表示正115。所以我们可以总结

=== 总结
- 无符号数，总是表示正数。所有位数都表示数值位。
- 有符号数，可以表示正数和负数，最高位是符号位，其余位都是数值位。如果符号位是0，则表示正数；如果符号位是1，则表示负数。对于负数的表示方法是：数值位全部取反，再加1，得到的数值就是负数值。

== 原码、反码、补码
=== 原码
原码的表示范围-127~-0, +0~+127, 共256个数字

正0的原码是0000 0000, 负0的原码是1000 0000, 有正0负0之分, 不符合人的习惯, 待解决.

=== 反码
除符号位, 原码其余位取反而得

+0：0000 0000，-0：1111 1111 仍然有正0负0之分。

=== 补码
在反码的基础上加1而得

对原码的两种0同时末位加1

+0：0000 0000，-0：0000 0000(因为溢出导致8位全0)

消除了正0负0之别, 如此一来, 便节省出一个数值表示方式1000 0000, 不能浪费, 用来表示-128, -128特殊之处在于没有相应的反码原码。也可以这样考虑:

```
-1：   1111 1111
-2：   1111 1110（在-1的基础上减1，直接将补码减1即可）
-3：   1111 1101（在-2补码基础上减1，以下类似）
-4：   1111 1100
……
-127：1000 0001
-128：1000 0000
```

如此以来：8位补码表示范围是-128~+127因为0只有一种形式所以，仍然是256个数

若8位代表无符号数, 则表示范围是 : 0~255, 这就是为什么高级语言讲到数据类型，

=== 原码，反码，补码的应用

== 负数的十进制和二进制转换
=== 十进制转二进制
方法为:

- 先转换为二进制
- 对二进制数求反
- 再将该二进制数加一

总而言之: 十进制数转换为二进制数求补码即为结果

==== 例子
-32 转换为二进制

- 第一步：32（10）=00100000（2）
- 第二步：求反：11011111
- 第三步：加1:11100000

所以-32（10）=11100000（2）

=== 二进制转十进制
方法为:

- 数值为取反
- 对该二进制加一
- 转换为10进制

==== 例子
11001000 转换为十进制

- 第一步（数值位取反）： 10110111
- 第二步（加一）：10111000
- 第三部（十进制）：-56

所以11001000（2）=-56（10）

== 十进制数求反的规律
下面都是以10进制表示:
=== 负数求反
负数求反等于其绝对值 `-1`

如:
```python
num = -5
num1 = ~num # 4
```

=== 正数求反
正数求反等于其值 `+1` 的负数
如:
```python
num = 4
num1 = ~num # -5
```

== 二进制的应用场景
